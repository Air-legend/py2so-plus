# lockpy2so
Python files encryption（as .so file）
English explain:

The cythonize library can compile .py files into .so DLL files .so files can be imported through normal import, but the source code can't be viewed.
In some cases, the relative path of files generated by the cythonize library after compilation will change, and I haven't found a quick solution yet.
But fortunately，During the compilation of cythonize, a temporary file will be generated and store the *. O files, and their paths is correct absolutely. On this basis, if there is a problem of file path error, the script will delete the current dynamic file and re compile through .O files.

The program needs to install GCC and Cython, which can be installed directly through pip install Cython.

Put the lock.py in the same level directory of the project folder which you want to encrypt,and run:

python3 lock.py -d [target_folder] -i [files dont need encrypt] -f [folders dont need encrypt] -v [python version]

For example:
  python lock.py -d My_Test -i My_Test/main.py -f My_Test/test -v 3.6

PS:I tested this script in Python 3.6

中文解释：

  cythonize库可以将.py文件编译为.so动态链接库文件，so文件可以通过正常import导入，但无法查看其源码（除非报错哈哈哈），因此在一定程度上可以对代码进行保护。
  第三方库cythonize在某些情况下：如项目中存在动态导入方法，无法找到动态导入文件的层级关系，此时生成的so文件相对路径就会发生偏差，我没有找到其他更简单的解决办法。
  在cythonize编译过程中会产生一个临时文件存放经过gcc编译的*.o文件且他们的路径不会出现问题，以此为基础，假如发生了文件路径错误的问题，脚本会删除当前动态文件，重新通过.o编译。
  
  程序需要安装gcc与Cython， Cython可以通过pip install Cython直接安装即可。
  
  将lock.py文件放在需要编译的工程文件同一级下，使用以下命令即可。
  
  python3 lock.py -d [需要编译的文件夹] -i [不需要编译的文件] -f [不需要编译的文件夹] -v [需要编译的python版本(2或3不同)]
  
举个栗子：
  我在3.6的环境下写的代码，项目根目录叫My_Test，不需要编译项目入口文件My_Test/main.py，不需要编译的文件夹My_Test/test。
  python lock.py -d My_Test -i My_Test/main.py -f My_Test/test -v 3.6


  第一次上传还有很多不懂得地方，希望大家可以提出来，多多指教。
  祝大家科研快乐！哈哈哈！

